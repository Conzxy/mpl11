/*
Copyright 2012-2014 Louis Dionne

Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.

*/
#ifndef BOOST_MPL11_MIN_HPP
#define BOOST_MPL11_MIN_HPP
namespace boost { namespace mpl11 { namespace detail { using std_size_t = decltype(sizeof(int)); }}} namespace boost { namespace mpl11 { struct Integer; template <typename T, T v> struct integer_c { using value_type = T; static constexpr value_type value = v; constexpr operator value_type() const { return value; } constexpr value_type operator()() const { return value; } using type = integer_c; using mpl_datatype = Integer; }; template <typename T, T v> using integral_c = integer_c<T, v>; template <bool B> using bool_ = integer_c<bool, B>; using true_ = bool_<true>; using false_ = bool_<false>; template <char C> using char_ = integer_c<char, C>; template <short N> using short_ = integer_c<short, N>; template <unsigned short N> using ushort = integer_c<unsigned short, N>; template <int N> using int_ = integer_c<int, N>; template <unsigned int N> using uint = integer_c<unsigned int, N>; template <long N> using long_ = integer_c<long, N>; template <unsigned long N> using ulong = integer_c<unsigned long, N>; template <long long N> using llong = integer_c<long long, N>; template <unsigned long long N> using ullong = integer_c<unsigned long long, N>; template <detail::std_size_t N> using size_t = integer_c<detail::std_size_t, N>; }} namespace boost { namespace mpl11 { template <typename Left, typename Right = Left, typename = true_> struct Bitwise; template <typename x1, typename x2, typename ...xn> struct bitand_; template <typename x1, typename x2, typename ...xn> struct bitor_; template <typename x1, typename x2, typename ...xn> struct bitxor; template <typename x, typename n> struct shift_right; template <typename x, detail::std_size_t n> using shift_right_c = shift_right<x, size_t<n>>; template <typename x, typename n> struct shift_left; template <typename x, detail::std_size_t n> using shift_left_c = shift_left<x, size_t<n>>; template <typename x> struct compl_; }} namespace boost { namespace mpl11 { template <typename Left, typename Right = Left, typename = true_> struct Comparable; template <typename x1, typename x2, typename ...xs> struct equal; template <typename x, typename y> struct not_equal; }} namespace boost { namespace mpl11 { template <template <typename ...> class Typeclass> struct instantiate; struct Foreign; template <typename ctor> struct datatype; namespace core_detail { template <typename...> struct undefined_; } using undefined = core_detail::undefined_<>; template <typename x> struct box; template <typename From, typename To> struct cast; template <typename To> struct cast_to; namespace core { using mpl11::instantiate; using mpl11::Foreign; using mpl11::datatype; using mpl11::undefined; using mpl11::box; using mpl11::cast; using mpl11::cast_to; } }} namespace boost { namespace mpl11 { template <typename ...xs> struct and_; template <typename ...xs> struct or_; template <typename x> struct not_; namespace logical_detail { template <bool> struct if_impl; } template <bool Condition, typename Then, typename Else> using if_c = typename logical_detail::if_impl<Condition>:: template result<Then, Else>; template <bool Condition, typename Then, typename Else> using else_if_c = if_c<Condition, Then, Else>; template <typename Condition, typename Then, typename Else> struct if_; template <typename Condition, typename Then, typename Else> using else_if = if_<Condition, Then, Else>; template <typename Else> using else_ = Else; }} namespace boost { namespace mpl11 { template <> struct instantiate<Comparable> { template <typename Left, typename Right = Left> struct with : true_ { template <typename x, typename y> using equal_impl = not_<not_equal<box<x>, box<y>>>; template <typename x, typename y> using not_equal_impl = not_<equal<box<x>, box<y>>>; }; }; }} namespace boost { namespace mpl11 { namespace detail { template <typename ...> struct dependent { template <typename T> using type = T; template <typename T> static constexpr T value(T x) { return x; } }; }}} namespace boost { namespace mpl11 { template <typename x> struct always; template <typename f> struct flip; template <typename f, typename ...x> struct apply; template <typename f, typename ...x> struct apply_curried; template <typename x> using id = x; template <template <typename ...> class f> struct lift; template <template <typename ...> class tp> struct into; template <typename f, typename ...x> struct partial; template <detail::std_size_t n, typename f> struct curry; template <detail::std_size_t n, typename f> struct uncurry; template <typename f> struct fix; template <typename f, typename ...fs> struct compose; template <typename f, typename g> struct argmap; template <typename f, typename ...fs> struct on; template <typename f, typename ...fs> struct bind; template <detail::std_size_t n> struct arg; template <typename x, typename f, typename y> using infix = apply<f, x, y>; template <typename x, template <typename ...> class f, typename y> using infix_ = f<x, y>; template <typename x, typename f> using lsect = partial<f, x>; template <typename x, template <typename ...> class f> using lsect_ = lsect<x, lift<f>>; template <typename f, typename y> using rsect = partial<flip<f>, y>; template <template <typename ...> class f, typename y> using rsect_ = rsect<lift<f>, y>; namespace functional { using mpl11::always; using mpl11::apply; using mpl11::apply_curried; using mpl11::arg; using mpl11::argmap; using mpl11::bind; using mpl11::compose; using mpl11::curry; using mpl11::fix; using mpl11::flip; using mpl11::id; using mpl11::infix; using mpl11::infix_; using mpl11::into; using mpl11::lift; using mpl11::lsect; using mpl11::lsect_; using mpl11::on; using mpl11::partial; using mpl11::rsect; using mpl11::rsect_; using mpl11::uncurry; } }} namespace boost { namespace mpl11 { namespace detail { template <std_size_t ...I> struct std_index_sequence; namespace index_sequence_detail { template <typename L, typename R> struct concat; template <std_size_t ...I, std_size_t ...J> struct concat<std_index_sequence<I...>, std_index_sequence<J...>> { using type = std_index_sequence<I..., (sizeof...(I) + J)...>; }; } template <std_size_t n> struct make_std_index_sequence { using type = typename index_sequence_detail::concat< typename make_std_index_sequence<n / 2>::type, typename make_std_index_sequence<n - n / 2>::type >::type; }; template <> struct make_std_index_sequence<0> { using type = std_index_sequence<>; }; template <> struct make_std_index_sequence<1> { using type = std_index_sequence<0>; }; }}} namespace boost { namespace mpl11 { namespace detail { namespace at_index { template <typename ignore> struct overload_impl; template <std_size_t ...ignore> struct overload_impl<std_index_sequence<ignore...>> { template <typename nth> static nth apply(decltype(ignore, (void*)nullptr)..., nth*, ...); }; template <std_size_t index, typename ...xs> using overload_resolution = decltype( overload_impl<typename make_std_index_sequence<index>::type>::apply( (xs*)nullptr... ) ); }}}} namespace boost { namespace mpl11 { namespace detail { namespace at_index { template <std_size_t index, typename ...xs> using best = overload_resolution<index, xs...>; }}}} namespace boost { namespace mpl11 { namespace detail { namespace left_folds { template <std_size_t n> struct variadic_aliased_impl; template <> struct variadic_aliased_impl< 6 > { template < template <typename ...> class f, typename state , typename x1, typename x2, typename x3, typename x4, typename x5, typename x6, typename ...xs> using apply = typename variadic_aliased_impl< (sizeof...(xs) > 6 ? 6 : sizeof...(xs)) >:: template apply< f, f<f<f<f<f<f<state, x1>, x2>, x3>, x4>, x5>, x6>, xs... >; }; template <> struct variadic_aliased_impl< 0 > { template < template <typename ...> class f, typename state > using apply = state; }; template <> struct variadic_aliased_impl< 1 > { template < template <typename ...> class f, typename state , typename x1 > using apply = f<state, x1>; }; template <> struct variadic_aliased_impl< 2 > { template < template <typename ...> class f, typename state , typename x1, typename x2 > using apply = f<f<state, x1>, x2>; }; template <> struct variadic_aliased_impl< 3 > { template < template <typename ...> class f, typename state , typename x1, typename x2, typename x3 > using apply = f<f<f<state, x1>, x2>, x3>; }; template <> struct variadic_aliased_impl< 4 > { template < template <typename ...> class f, typename state , typename x1, typename x2, typename x3, typename x4 > using apply = f<f<f<f<state, x1>, x2>, x3>, x4>; }; template <> struct variadic_aliased_impl< 5 > { template < template <typename ...> class f, typename state , typename x1, typename x2, typename x3, typename x4, typename x5 > using apply = f<f<f<f<f<state, x1>, x2>, x3>, x4>, x5>; }; template <template <typename ...> class f, typename state, typename ...xs> struct variadic_aliased : variadic_aliased_impl< (sizeof...(xs) > 6 ? 6 : sizeof...(xs)) >:: template apply<f, state, xs...> { }; }}}} namespace boost { namespace mpl11 { namespace detail { namespace left_folds { template <template <typename ...> class f, typename state, typename ...xs> using variadic = variadic_aliased<f, state, xs...>; }}}} namespace boost { namespace mpl11 { template <typename x> struct always { using type = always; template <typename ...> using apply = x; }; template <typename f, typename ...x> struct apply : f::type::template apply<x...> { }; template <typename f> struct flip { using type = flip; template <typename x0, typename x1, typename ...xs> struct apply : f::type::template apply<x1, x0, xs...> {}; }; template <typename f, typename ...x> struct partial { using type = partial; template <typename ...y> using apply = typename f::type::template apply<x..., y...>; }; template <template <typename ...> class f, typename ...x> struct partial<lift<f>, x...> { using type = partial; template <typename ...y> struct apply : f<x..., y...> { }; }; template <template <typename ...> class f, typename ...x> struct partial<into<f>, x...> { using type = partial; template <typename ...y> struct apply { using type = f<x..., y...>; }; }; template <typename f, typename ...xs> struct apply_curried : detail::left_folds::variadic<apply, f, xs...> { }; template <detail::std_size_t n, typename f> struct curry { static_assert(n > 0, "Invalid usage of curry<n, f> with a zero-valued n."); using type = curry; template <typename x> using apply = curry<n-1, partial<f, x>>; }; template <typename f> struct curry<1, f> { using type = curry; template <typename x> using apply = typename f::type::template apply<x>; }; template <detail::std_size_t n, typename f> struct uncurry { using type = uncurry; static_assert(n > 0, "Invalid usage of uncurry<n, f> with a zero-valued n."); template <typename ...xs> struct apply : apply_curried<f, xs...> { static_assert(sizeof...(xs) <= n, "Invalid usage of uncurry<n, f> with more than n arguments."); static_assert(sizeof...(xs) >= n, "Invalid usage of uncurry<n, f> with less than n arguments."); }; }; template <template <typename ...> class f> struct lift { using type = lift; template <typename ...x> struct apply : f<x...> { }; }; template <template <typename ...> class tp> struct into { using type = into; template <typename ...x> struct apply { using type = tp<x...>; }; }; template <typename f> struct fix : partial<f, fix<f>> { }; namespace functional_detail { template <bool has_zero_args> struct compose_impl; template <> struct compose_impl<true> { template <typename f, typename g> using apply = typename f::type::template apply< typename g::type::template apply<> >; }; template <> struct compose_impl<false> { template <typename f, typename g, typename x, typename ...xs> using apply = typename f::type::template apply< typename g::type::template apply<x>, xs... >; }; } template <typename f, typename ...fs> struct compose { using type = compose; template <typename ...xs> using apply = typename functional_detail::compose_impl<sizeof...(xs) == 0>:: template apply<f, compose<fs...>, xs...>; }; template <typename f> struct compose<f> : f { }; template <typename f, typename g> struct argmap { using type = argmap; template <typename ...x> using apply = typename f::type::template apply< typename g::type::template apply<x>... >; }; template <typename f, typename ...fs> struct on { using type = on; template <typename ...x> using apply = typename f::type::template apply< typename fs::type::template apply<x>... >; }; template < template <typename ...> class f, template <typename ...> class ...fs > struct on<lift<f>, lift<fs>...> { using type = on; template <typename ...x> using apply = f<fs<x>...>; }; template <typename f, typename ...fs> struct bind { using type = bind; template <typename ...x> using apply = typename f::type::template apply< typename fs::type::template apply<x...>... >; }; template < template <typename ...> class f, template <typename ...> class ...fs > struct bind<lift<f>, lift<fs>...> { using type = bind; template <typename ...x> using apply = f<fs<x...>...>; }; template <> struct arg<0>; template <detail::std_size_t n> struct arg { using type = arg; template <typename ...an> using apply = detail::at_index::best<n-1, an...>; }; }} namespace boost { namespace mpl11 { namespace core_detail { template <typename ...xs> struct undefined_ { static_assert(detail::dependent<xs...>::value(false), "Error: `undefined` may not be instantiated."); }; } template <template <typename ...> class Typeclass> struct instantiate { template <typename ...> using with = true_; }; template <typename x> struct box { using type = x; }; namespace core_detail { template <typename T> auto pick_datatype(T*) -> typename T::mpl_datatype; auto pick_datatype(...) -> Foreign; } template <typename ctor> struct datatype { using type = decltype(core_detail::pick_datatype((ctor*)nullptr)); }; template <typename To> struct cast_to { using type = cast_to; template <typename x> using apply = typename cast< typename datatype<x>::type, To >::type::template apply<x>; }; namespace core_detail { template <typename> struct foreign { using type = foreign; using mpl_datatype = Foreign; }; } template <typename From> struct cast<From, Foreign> { using type = cast; template <typename x> using apply = core_detail::foreign<x>; }; template <> struct cast<Foreign, Foreign> : lift<box> { }; }} namespace boost { namespace mpl11 { namespace detail { template <typename T, typename U> struct std_is_same { static constexpr bool value = false; using type = std_is_same; }; template <typename T> struct std_is_same<T, T> { static constexpr bool value = true; using type = std_is_same; }; }}} namespace boost { namespace mpl11 { namespace detail { namespace right_folds { template <template <typename ...> class f, typename state, typename ...xs> struct variadic_unrolled; template < template <typename ...> class f, typename state , typename x0, typename x1, typename x2, typename x3, typename x4, typename x5, typename ...xs> struct variadic_unrolled<f, state , x0, x1, x2, x3, x4, x5, xs...> : f<x0, f<x1, f<x2, f<x3, f<x4, f<x5, variadic_unrolled<f, state, xs...>>>>>>> { }; template < template <typename ...> class f, typename state > struct variadic_unrolled<f, state > : state { }; template < template <typename ...> class f, typename state , typename x0 > struct variadic_unrolled<f, state , x0 > : f<x0, state> { }; template < template <typename ...> class f, typename state , typename x0, typename x1 > struct variadic_unrolled<f, state , x0, x1 > : f<x0, f<x1, state>> { }; template < template <typename ...> class f, typename state , typename x0, typename x1, typename x2 > struct variadic_unrolled<f, state , x0, x1, x2 > : f<x0, f<x1, f<x2, state>>> { }; template < template <typename ...> class f, typename state , typename x0, typename x1, typename x2, typename x3 > struct variadic_unrolled<f, state , x0, x1, x2, x3 > : f<x0, f<x1, f<x2, f<x3, state>>>> { }; template < template <typename ...> class f, typename state , typename x0, typename x1, typename x2, typename x3, typename x4 > struct variadic_unrolled<f, state , x0, x1, x2, x3, x4 > : f<x0, f<x1, f<x2, f<x3, f<x4, state>>>>> { }; }}}} namespace boost { namespace mpl11 { namespace detail { namespace right_folds { template <template <typename ...> class f, typename state, typename ...xs> using variadic = variadic_unrolled<f, state, xs...>; }}}} namespace boost { namespace mpl11 { namespace logical_detail { template <bool cond> struct if_impl; template <> struct if_impl<true> { template <typename Then, typename Else> using result = Then; }; template <> struct if_impl<false> { template <typename Then, typename Else> using result = Else; }; template <typename x, typename y> struct and2 : bool_< (bool)if_c<(bool)x::type::value, y, x>::type::value > { }; template <typename x, typename y> struct or2 : bool_< (bool)if_c<(bool)x::type::value, x, y>::type::value > { }; } template <typename ...xs> struct and_ : detail::right_folds::variadic<logical_detail::and2, true_, xs...> { }; template <typename ...xs> struct or_ : detail::right_folds::variadic<logical_detail::or2, false_, xs...> { }; template <typename x> struct not_ : bool_<!x::type::value> { }; template <typename Condition, typename Then, typename Else> struct if_ : logical_detail::if_impl<(bool)Condition::type::value>:: template result<Then, Else> { }; }} namespace boost { namespace mpl11 { namespace core_detail { template <typename ...datatypes> struct invalid_cast { static_assert(detail::dependent<datatypes...>::value(false), "No cast is provided between the two requested datatypes."); }; } template <typename From, typename To> struct cast : if_c<detail::std_is_same<From, To>::value, lift<box>, core_detail::invalid_cast<From, To> > { }; }} namespace boost { namespace mpl11 { template <typename Left, typename Right, typename> struct Comparable : instantiate<Comparable>::template with<Left, Right> { template <typename x, typename y> using equal_impl = bool_<detail::std_is_same<x, y>::value>; template <typename x, typename y> using not_equal_impl = bool_<!detail::std_is_same<x, y>::value>; }; template <typename x1, typename x2, typename ...xs> struct equal : and_<equal<x1, x2>, equal<x2, xs...>> { }; template <typename x, typename y> struct equal<x, y> : Comparable< typename datatype<typename x::type>::type, typename datatype<typename y::type>::type >::template equal_impl<typename x::type, typename y::type> { }; template <typename x, typename y> struct not_equal : Comparable< typename datatype<typename x::type>::type, typename datatype<typename y::type>::type >::template not_equal_impl<typename x::type, typename y::type> { }; }} namespace boost { namespace mpl11 { namespace detail { namespace logical_or { template <bool ...> struct strict_is_same_impl; template <typename ...xs> using strict_is_same = bool_< !std_is_same< strict_is_same_impl<(bool)xs::type::value...>, strict_is_same_impl<(xs::type::value, false)...> >::value >; }}}} namespace boost { namespace mpl11 { namespace detail { namespace logical_or { template <typename ...xs> using strict = strict_is_same<xs...>; }}}} namespace boost { namespace mpl11 { template <typename Datatype, typename = true_> struct Enumerable; template <typename e> struct succ; template <typename e> struct pred; }} namespace boost { namespace mpl11 { template <typename e> struct succ : Enumerable<typename datatype<typename e::type>::type>:: template succ_impl<typename e::type> { }; template <typename e> struct pred : Enumerable<typename datatype<typename e::type>::type>:: template pred_impl<typename e::type> { }; }} namespace boost { namespace mpl11 { template <typename Left, typename Right = Left, typename = true_> struct Group; template <typename x, typename y> struct minus; template <typename x> struct negate; }} namespace boost { namespace mpl11 { template <typename Left, typename Right = Left, typename = true_> struct Monoid; template <typename x1, typename x2, typename ...xn> struct plus; template <typename Datatype> struct zero; }} namespace boost { namespace mpl11 { template <> struct instantiate<Group> { template <typename Left, typename Right = Left> struct with; template <typename Datatype> struct with<Datatype> : true_ { template <typename x, typename y> using minus_impl = plus<box<x>, negate<box<y>>>; template <typename x> using negate_impl = minus<zero<Datatype>, box<x>>; }; }; }} namespace boost { namespace mpl11 { template <typename Left, typename Right, typename> struct Group : false_ { }; template <typename x, typename y> struct minus : Group< typename datatype<typename x::type>::type, typename datatype<typename y::type>::type >::template minus_impl<typename x::type, typename y::type> { }; template <typename x> struct negate : Group<typename datatype<typename x::type>::type>:: template negate_impl<typename x::type> { }; }} namespace boost { namespace mpl11 { template <typename Left, typename Right = Left, typename = true_> struct IntegralDomain; template <typename x, typename y> struct div; template <typename x, typename y> struct mod; }} namespace boost { namespace mpl11 { template <typename Left, typename Right, typename> struct IntegralDomain : false_ { }; template <typename x, typename y> struct div : IntegralDomain< typename datatype<typename x::type>::type, typename datatype<typename y::type>::type >::template div_impl<typename x::type, typename y::type> { }; template <typename x, typename y> struct mod : IntegralDomain< typename datatype<typename x::type>::type, typename datatype<typename y::type>::type >::template mod_impl<typename x::type, typename y::type> { }; }} namespace boost { namespace mpl11 { template <typename Left, typename Right, typename> struct Monoid : false_ { }; template <typename x1, typename x2, typename ...xn> struct plus : detail::left_folds::variadic<plus, x1, x2, xn...> { }; template <typename x, typename y> struct plus<x, y> : Monoid< typename datatype<typename x::type>::type, typename datatype<typename y::type>::type >::template plus_impl<typename x::type, typename y::type> { }; template <typename Datatype> struct zero : Monoid<Datatype>::template zero_impl<> { }; }} namespace boost { namespace mpl11 { template <typename Left, typename Right = Left, typename = true_> struct Orderable; template <typename x1, typename x2, typename ...xs> struct less; template <typename x1, typename x2, typename ...xs> struct less_equal; template <typename x1, typename x2, typename ...xs> struct greater; template <typename x1, typename x2, typename ...xs> struct greater_equal; template <typename x1, typename x2, typename ...xs> struct min; template <typename x1, typename x2, typename ...xs> struct max; }} namespace boost { namespace mpl11 { template <> struct instantiate<Orderable> { template <typename Left, typename Right = Left> struct with : true_ { template <typename x, typename y> using less_equal_impl = not_<less<box<y>, box<x>>>; template <typename x, typename y> using greater_impl = less<box<y>, box<x>>; template <typename x, typename y> using greater_equal_impl = not_<less<box<x>, box<y>>>; template <typename x, typename y> using min_impl = if_c<less<box<x>, box<y>>::value, box<x>, box<y>>; template <typename x, typename y> using max_impl = if_c<less<box<x>, box<y>>::value, box<y>, box<x>>; }; }; }} namespace boost { namespace mpl11 { template <typename Left, typename Right, typename> struct Orderable : false_ { }; template <typename x1, typename x2, typename ...xs> struct less : and_<less<x1, x2>, less<x2, xs...>> { }; template <typename x, typename y> struct less<x, y> : Orderable< typename datatype<typename x::type>::type, typename datatype<typename y::type>::type >::template less_impl<typename x::type, typename y::type> { }; template <typename x1, typename x2, typename ...xs> struct less_equal : and_<less_equal<x1, x2>, less_equal<x2, xs...>> { }; template <typename x, typename y> struct less_equal<x, y> : Orderable< typename datatype<typename x::type>::type, typename datatype<typename y::type>::type >::template less_equal_impl<typename x::type, typename y::type> { }; template <typename x1, typename x2, typename ...xs> struct greater : and_<greater<x1, x2>, greater<x2, xs...>> { }; template <typename x, typename y> struct greater<x, y> : Orderable< typename datatype<typename x::type>::type, typename datatype<typename y::type>::type >::template greater_impl<typename x::type, typename y::type> { }; template <typename x1, typename x2, typename ...xs> struct greater_equal : and_<greater_equal<x1, x2>, greater_equal<x2, xs...>> { }; template <typename x, typename y> struct greater_equal<x, y> : Orderable< typename datatype<typename x::type>::type, typename datatype<typename y::type>::type >::template greater_equal_impl<typename x::type, typename y::type> { }; template <typename x1, typename x2, typename ...xs> struct min : detail::left_folds::variadic<min, x1, x2, xs...> { }; template <typename x, typename y> struct min<x, y> : Orderable< typename datatype<typename x::type>::type, typename datatype<typename y::type>::type >::template min_impl<typename x::type, typename y::type> { }; template <typename x1, typename x2, typename ...xs> struct max : detail::left_folds::variadic<max, x1, x2, xs...> { }; template <typename x, typename y> struct max<x, y> : Orderable< typename datatype<typename x::type>::type, typename datatype<typename y::type>::type >::template max_impl<typename x::type, typename y::type> { }; }} namespace boost { namespace mpl11 { template <typename Left, typename Right = Left, typename = true_> struct Ring; template <typename x1, typename x2, typename ...xn> struct mult; template <typename Datatype> struct one; }} namespace boost { namespace mpl11 { template <typename Left, typename Right, typename> struct Ring : false_ { }; template <typename x1, typename x2, typename ...xn> struct mult : detail::left_folds::variadic<mult, x1, x2, xn...> { }; template <typename x, typename y> struct mult<x, y> : Ring< typename datatype<typename x::type>::type, typename datatype<typename y::type>::type >::template mult_impl<typename x::type, typename y::type> { }; template <typename Datatype> struct one : Ring<Datatype>::template one_impl<> { }; }} namespace boost { namespace mpl11 { template <typename T, T ...v> struct or_<integer_c<T, v>...> : detail::logical_or::strict<bool_<(bool)v>...> { }; template <typename T, T ...v> struct and_<integer_c<T, v>...> : bool_<!detail::logical_or::strict<bool_<!v>...>::value> { }; template <> struct Monoid<Integer> : instantiate<Monoid>::with<Integer> { template <typename x, typename y> using plus_impl = integer_c< decltype(x::value + y::value), x::value + y::value >; template <typename ...> using zero_impl = int_<0>; }; template <> struct Group<Integer> : instantiate<Group>::with<Integer> { template <typename x, typename y> using minus_impl = integer_c< decltype(x::value - y::value), x::value - y::value >; template <typename x> using negate_impl = integer_c< decltype(-x::value), -x::value >; }; template <> struct Ring<Integer> : instantiate<Ring>::with<Integer> { template <typename x, typename y> using mult_impl = integer_c< decltype(x::value * y::value), x::value * y::value >; template <typename ...> using one_impl = int_<1>; }; template <> struct IntegralDomain<Integer> : instantiate<IntegralDomain>::with<Integer> { template <typename x, typename y> using div_impl = integer_c< decltype(x::value / y::value), x::value / y::value >; template <typename x, typename y> using mod_impl = integer_c< decltype(x::value % y::value), x::value % y::value >; }; template <> struct Enumerable<Integer> : instantiate<Enumerable>::with<Integer> { template <typename x> using succ_impl = integer_c< decltype(x::value + 1), x::value + 1 >; template <typename x> using pred_impl = integer_c< decltype(x::value - 1), x::value - 1 >; }; template <> struct Comparable<Integer> : instantiate<Comparable>::with<Integer> { template <typename x, typename y> using equal_impl = bool_<x::value == y::value>; template <typename x, typename y> using not_equal_impl = bool_<x::value != y::value>; }; template <> struct Orderable<Integer> : instantiate<Orderable>::with<Integer> { template <typename x, typename y> using less_impl = bool_<(x::value < y::value)>; template <typename x, typename y> using less_equal_impl = bool_<(x::value <= y::value)>; template <typename x, typename y> using greater_impl = bool_<(x::value > y::value)>; template <typename x, typename y> using greater_equal_impl = bool_<(x::value >= y::value)>; template <typename x, typename y> using max_impl = if_c<(x::value < y::value), y, x>; template <typename x, typename y> using min_impl = if_c<(x::value < y::value), x, y>; }; template <> struct Bitwise<Integer> : instantiate<Bitwise>::with<Integer> { template <typename x, typename y> using bitand_impl = integer_c< decltype(x::value & y::value), x::value & y::value >; template <typename x, typename y> using bitor_impl = integer_c< decltype(x::value | y::value), x::value | y::value >; template <typename x, typename y> using bitxor_impl = integer_c< decltype(x::value ^ y::value), x::value ^ y::value >; template <typename x, typename n> using shift_left_impl = integer_c< decltype(x::value << n::value), (x::value << n::value) >; template <typename x, typename n> using shift_right_impl = integer_c< decltype(x::value >> n::value), (x::value >> n::value) >; template <typename x> using compl_impl = integer_c< decltype(~x::value), ~x::value >; }; }} namespace boost { namespace mpl11 { template <typename Left, typename Right, typename> struct Bitwise : false_ { }; template <typename x1, typename x2, typename ...xn> struct bitand_ : detail::left_folds::variadic<bitand_, x1, x2, xn...> { }; template <typename x, typename y> struct bitand_<x, y> : Bitwise< typename datatype<typename x::type>::type, typename datatype<typename y::type>::type >::template bitand_impl<typename x::type, typename y::type> { }; template <typename x1, typename x2, typename ...xn> struct bitor_ : detail::left_folds::variadic<bitor_, x1, x2, xn...> { }; template <typename x, typename y> struct bitor_<x, y> : Bitwise< typename datatype<typename x::type>::type, typename datatype<typename y::type>::type >::template bitor_impl<typename x::type, typename y::type> { }; template <typename x1, typename x2, typename ...xn> struct bitxor : detail::left_folds::variadic<bitxor, x1, x2, xn...> { }; template <typename x, typename y> struct bitxor<x, y> : Bitwise< typename datatype<typename x::type>::type, typename datatype<typename y::type>::type >::template bitxor_impl<typename x::type, typename y::type> { }; namespace bitwise_detail { template <typename x, typename n> struct lshift_checks { static_assert(n::type::value >= 0, "Invalid usage of `shift_left` with a negative shift."); }; template <typename x, typename n> struct rshift_checks { static_assert(n::type::value >= 0, "Invalid usage of `shift_right` with a negative shift."); }; } template <typename x, typename n> struct shift_left : bitwise_detail::lshift_checks<x, n>, Bitwise<typename datatype<typename x::type>::type>:: template shift_left_impl<typename x::type, n> { }; template <typename x, typename n> struct shift_right : bitwise_detail::rshift_checks<x, n>, Bitwise<typename datatype<typename x::type>::type>:: template shift_right_impl<typename x::type, n> { }; template <typename x> struct compl_ : Bitwise<typename datatype<typename x::type>::type>:: template compl_impl<typename x::type> { }; }} namespace boost { namespace mpl11 { template <typename Left, typename Right = Left, typename = true_> struct Field; template <typename x, typename y> struct quot; template <typename x> struct recip; }} namespace boost { namespace mpl11 { template <typename Left, typename Right, typename> struct Field : false_ { }; template <> struct instantiate<Field> { template <typename Left, typename Right = Left> struct with; template <typename Datatype> struct with<Datatype> : true_ { template <typename x, typename y> using quot_impl = mult<box<x>, recip<box<y>>>; template <typename x> using recip_impl = quot<one<Datatype>, box<x>>; }; }; template <typename x, typename y> struct quot : Field< typename datatype<typename x::type>::type, typename datatype<typename y::type>::type >::template quot_impl<typename x::type, typename y::type> { }; template <typename x> struct recip : Field<typename datatype<typename x::type>::type>:: template recip_impl<typename x::type> { }; }} namespace boost { namespace mpl11 { template <typename Datatype, typename = true_> struct Foldable; template <typename f, typename state, typename structure> struct foldr; template <typename f, typename structure> struct foldr1; template <typename f, typename state, typename structure> struct foldl; template <typename f, typename structure> struct foldl1; template <typename predicate, typename structure> using all = foldr< compose<lift<and_>, predicate>, true_, structure >; template <typename structure> using all_of = all<lift<id>, structure>; template <typename predicate, typename structure> using none = all<compose<lift<not_>, predicate>, structure>; template <typename structure> using none_of = none<lift<id>, structure>; template <typename predicate, typename structure> using any = not_<none<predicate, structure>>; template <typename structure> using any_of = any<lift<id>, structure>; template <typename structure> using sum = foldr<lift<plus>, zero<Integer>, structure>; template <typename structure> using product = foldr<lift<mult>, one<Integer>, structure>; template <typename predicate, typename structure> using maximum_by = foldr1<bind<lift<if_>, predicate, arg<2>, arg<1>>, structure>; template <typename structure> using maximum = foldr1<lift<max>, structure>; template <typename predicate, typename structure> using minimum_by = foldr1<bind<lift<if_>, predicate, arg<1>, arg<2>>, structure>; template <typename structure> using minimum = foldr1<lift<min>, structure>; template <typename f, typename structure> using unpack = apply<foldl<lift<partial>, f, structure>>; }} namespace boost { namespace mpl11 { struct Maybe; template <typename x> struct just; struct nothing ; template <typename def, typename f, typename m> struct maybe; template <typename m> using is_just = maybe<false_, always<true_>, m>; template <typename m> using is_nothing = maybe<true_, always<false_>, m>; template <typename def, typename m> using from_maybe = maybe<def, lift<id>, m>; namespace maybe_detail { template <typename ...> struct err_from_just; } template <typename m> using from_just = maybe<maybe_detail::err_from_just<>, lift<id>, m>; }} namespace boost { namespace mpl11 { template <typename Datatype, typename = true_> struct Functor; template <typename f, typename structure> struct fmap; }} namespace boost { namespace mpl11 { template <typename Datatype, typename> struct Functor : false_ { }; template <typename f, typename structure> struct fmap : Functor<typename datatype<typename structure::type>::type>:: template fmap_impl<f, typename structure::type> { }; template <typename f, typename g, typename structure> struct fmap<f, fmap<g, structure>> : fmap<compose<f, g>, structure> { }; }} namespace boost { namespace mpl11 { template <typename x> struct just { using type = just; using mpl_datatype = Maybe; template <typename def, typename f> using maybe_ = typename f::type::template apply<x>; }; struct nothing { using type = nothing; using mpl_datatype = Maybe; template <typename def, typename f> using maybe_ = def; }; template <typename def, typename f, typename m> struct maybe : m::type::template maybe_<def, f> { }; namespace maybe_detail { template <typename ...dum> struct err_from_just { static_assert(detail::dependent<dum...>::value(false), "Using from_just on a nothing."); struct type; }; } template <> struct Functor<Maybe> : instantiate<Functor>::with<Maybe> { template <typename f, typename m> using fmap_impl = typename m::template maybe_<nothing, f>; }; }} namespace boost { namespace mpl11 { template <typename Datatype, typename> struct Foldable : false_ { }; template <> struct instantiate<Foldable> { private: template <typename f> struct maybe_f { using type = maybe_f; template <typename x, typename y> using apply = just<maybe<x, partial<f, x>, y>>; }; public: template <typename Datatype> struct with : true_ { template <typename f, typename structure> using foldr1_impl = from_just< foldr<maybe_f<f>, nothing, box<structure>> >; template <typename f, typename structure> using foldl1_impl = from_just< foldl<flip<maybe_f<flip<f>>>, nothing, box<structure>> >; }; }; template <typename f, typename state, typename structure> struct foldr : Foldable<typename datatype<typename structure::type>::type>:: template foldr_impl<f, state, typename structure::type> { }; template <typename f, typename state, typename structure> struct foldl : Foldable<typename datatype<typename structure::type>::type>:: template foldl_impl<f, state, typename structure::type> { }; namespace foldable_detail { template <typename xs> using is_empty_structure = foldr<always<false_>, true_, xs>; template <typename structure> struct fold1_checks { static_assert(!is_empty_structure<structure>::value, "Invalid usage of foldr1 or foldl1 with an empty structure."); }; } template <typename f, typename structure> struct foldr1 : foldable_detail::fold1_checks<structure>, Foldable<typename datatype<typename structure::type>::type>:: template foldr1_impl<f, typename structure::type> { }; template <typename f, typename structure> struct foldl1 : foldable_detail::fold1_checks<structure>, Foldable<typename datatype<typename structure::type>::type>:: template foldl1_impl<f, typename structure::type> { }; }} namespace boost { namespace mpl11 { template <typename Datatype, typename = true_> struct Iterable; template <typename iter> struct head; template <typename iter> struct tail; template <typename iter> struct last; template <typename iter> struct length; template <typename index, typename iter> struct at; template <detail::std_size_t index, typename iter> using at_c = at<size_t<index>, iter>; template <typename iter> struct is_empty; template <typename n, typename iter> struct drop; template <detail::std_size_t n, typename iter> using drop_c = drop<size_t<n>, iter>; template <typename predicate, typename iter> struct drop_while; template <typename predicate, typename iter> using drop_until = drop_while<compose<lift<not_>, predicate>, iter>; }} namespace boost { namespace mpl11 { namespace detail { namespace left_folds { template <bool done> struct until_aliased_impl; template <> struct until_aliased_impl<true> { template < template <typename ...> class pred, template <typename ...> class f, typename state, typename xs> using apply = state; }; template <> struct until_aliased_impl<false> { template < template <typename ...> class pred, template <typename ...> class f, typename state, typename xs> using apply = typename until_aliased_impl<pred<tail<xs>>::type::value>:: template apply<pred, f, f<state, head<xs>>, tail<xs>>; }; template < template <typename ...> class predicate, template <typename ...> class f, typename state, typename xs> using until_aliased = typename until_aliased_impl<predicate<xs>::type::value>:: template apply<predicate, f, state, xs>; }}}} namespace boost { namespace mpl11 { namespace detail { namespace left_folds { template < template <typename ...> class predicate, template <typename ...> class f, typename state, typename xs > using until = until_aliased<predicate, f, state, xs>; }}}} namespace boost { namespace mpl11 { namespace detail { namespace right_folds { template < template <typename ...> class predicate, template <typename ...> class f, typename state, typename xs, bool = predicate<xs>::type::value> struct until_naive; template < template <typename ...> class p, template <typename ...> class f, typename state, typename xs> struct until_naive<p, f, state, xs, true> : state { }; template < template <typename ...> class p, template <typename ...> class f, typename state, typename xs> struct until_naive<p, f, state, xs, false> : f<head<xs>, until_naive<p, f, state, tail<xs>>> { }; }}}} namespace boost { namespace mpl11 { namespace detail { namespace right_folds { template < template <typename ...> class predicate, template <typename ...> class f, typename state, typename xs > using until = until_naive<predicate, f, state, xs>; }}}} namespace boost { namespace mpl11 { namespace iterable_detail { template <detail::std_size_t n, typename iter, bool = n == 0 || is_empty<iter>::value> struct drop_impl; template <detail::std_size_t n, typename iter> struct drop_impl<n, iter, true> : iter { }; template <detail::std_size_t n, typename iter> struct drop_impl<n, iter, false> : drop_impl<n-1, tail<iter>> { }; template <typename iter> struct head_checks { static_assert(!is_empty<iter>::value, "Invalid usage of `head` on an empty iterable."); }; template <typename iter> struct tail_checks { static_assert(!is_empty<iter>::value, "Invalid usage of `tail` on an empty iterable."); }; template <typename iter> struct last_checks { static_assert(!is_empty<iter>::value, "Invalid usage of `last` on an empty iterable."); }; template <typename index, typename iter> struct at_checks { static_assert(index::type::value >= 0, "Invalid usage of `at` with a negative index."); }; template <typename n, typename iter> struct drop_checks { static_assert(n::type::value >= 0, "Invalid usage of `drop`: " "The number of elements to drop must be non-negative."); }; template <typename p> struct drop_while_pred { using type = drop_while_pred; template <typename xs> using apply = or_< is_empty<xs>, not_<typename p::type::template apply<head<xs>>> >; }; } template <typename pred, typename iterable> struct drop_while : detail::left_folds::until< iterable_detail::drop_while_pred<pred>::type::template apply , bind<lift<tail>, arg<1>>::type::template apply , iterable , iterable > { }; template <typename iter> struct head : iterable_detail::head_checks<iter>, Iterable<typename datatype<typename iter::type>::type>:: template head_impl<typename iter::type> { }; template <typename iter> struct tail : iterable_detail::tail_checks<iter>, Iterable<typename datatype<typename iter::type>::type>:: template tail_impl<typename iter::type> { }; template <typename iter> struct last : iterable_detail::last_checks<iter>, Iterable<typename datatype<typename iter::type>::type>:: template last_impl<typename iter::type> { }; template <typename index, typename iter> struct at : iterable_detail::at_checks<index, iter>, Iterable<typename datatype<typename iter::type>::type>:: template at_impl<index, typename iter::type> { }; template <typename n, typename iter> struct drop : iterable_detail::drop_checks<n, iter>, iterable_detail::drop_impl<n::type::value, iter> { }; template <typename iter> struct is_empty : Iterable<typename datatype<typename iter::type>::type>:: template is_empty_impl<typename iter::type> { }; template <typename iter> struct length : Iterable<typename datatype<typename iter::type>::type>:: template length_impl<typename iter::type> { }; template <typename Datatype, typename> struct Iterable : false_ { }; namespace iterable_detail { struct plus_one { using type = plus_one; template <typename x, typename _> using apply = succ<x>; }; } template <> struct instantiate<Iterable> { template <typename Datatype> struct with : true_ { template <typename xs> using last_impl = foldl<arg<2>, undefined, box<xs>>; template <typename index, typename xs, bool = index::type::value == 0> struct at_impl : head<box<xs>> { }; template <typename index, typename xs> struct at_impl<index, xs, false> : at_impl< size_t<index::type::value - 1>, typename tail<box<xs>>::type > { }; template <typename xs> using length_impl = foldl<iterable_detail::plus_one, int_<0>, box<xs>>; }; }; template <typename X, typename Y> struct Orderable<X, Y, bool_<Iterable<X>::value && Iterable<Y>::value>> : instantiate<Orderable>::template with<X, Y> { template <typename xs, typename ys, bool xs_done = is_empty<box<xs>>::value, bool ys_done = is_empty<box<ys>>::value > struct less_impl : bool_<xs_done && !ys_done> { }; template <typename xs, typename ys> struct less_impl<xs, ys, false, false> : or_< less<head<box<xs>>, head<box<ys>>>, and_< not_<less<head<box<ys>>, head<box<xs>>>>, less_impl< typename tail<box<xs>>::type, typename tail<box<ys>>::type > > > { }; }; template <typename X, typename Y> struct Comparable<X, Y, bool_<Iterable<X>::value && Iterable<Y>::value>> : instantiate<Comparable>::template with<X, Y> { template <typename xs, typename ys, bool xs_done = is_empty<box<xs>>::value, bool ys_done = is_empty<box<ys>>::value> struct equal_impl : bool_<xs_done && ys_done> { }; template <typename xs, typename ys> struct equal_impl<xs, ys, false, false> : and_< equal<head<box<xs>>, head<box<ys>>>, equal_impl< typename tail<box<xs>>::type, typename tail<box<ys>>::type > > { }; }; template <typename Datatype> struct Foldable<Datatype, typename Iterable<Datatype>::type> : instantiate<Foldable>::template with<Datatype> { template <typename f, typename state, typename iterable> using foldl_impl = detail::left_folds::until< is_empty, f::type::template apply, state, box<iterable> >; template <typename f, typename iterable> using foldl1_impl = detail::left_folds::until< is_empty, f::type::template apply, head<box<iterable>>, tail<box<iterable>> >; template <typename f, typename state, typename iterable> using foldr_impl = detail::right_folds::until< is_empty, f::type::template apply, state, box<iterable> >; }; }} namespace boost { namespace mpl11 { struct List ; template <typename ...xs> struct list; template <typename ...xs> using list_ = list<box<xs>...>; template <typename x, typename xs> struct cons; template <typename xs, typename x> using snoc = foldr<lift<cons>, list<x>, xs>; template <typename f, typename x> struct iterate; template <typename x> struct repeat; template <typename n, typename xs> struct take; template <detail::std_size_t n, typename xs> using take_c = take<size_t<n>, xs>; namespace list_detail { template <typename predicate> struct take_while_op; template <typename predicate> struct filter_op; } template <typename predicate, typename xs> using take_while = foldr<list_detail::take_while_op<predicate>, list<>, xs>; template <typename predicate, typename xs> using take_until = take_while<compose<lift<not_>, predicate>, xs>; template <typename xs> using reverse = foldl<flip<lift<cons>>, list<>, xs>; template <typename predicate, typename xs> using filter = foldr<list_detail::filter_op<predicate>, list<>, xs>; template <typename f, typename state, typename xs> struct scanl; template <typename f, typename ...lists> struct zip_with; template <typename ...lists> using zip = zip_with<lift<list>, lists...>; template <typename ...lists> struct concat; template <typename xs, typename start, typename stop> struct slice; template <typename xs, detail::std_size_t start, detail::std_size_t stop> using slice_c = slice<xs, size_t<start>, size_t<stop>>; template <typename predicate, typename xs> struct sort_by; template <typename xs> struct init; }} namespace boost { namespace mpl11 { template <typename ...xs> struct list { using type = list; using mpl_datatype = List; }; template <typename x, typename xs> struct cons { using type = cons; using mpl_datatype = List; }; template <> struct Iterable<List> : instantiate<Iterable>::with<List> { template <typename> struct head_impl; template <typename x, typename xs> struct head_impl<cons<x, xs>> : x { }; template <typename x, typename ...xs> struct head_impl<list<x, xs...>> : x { }; template <typename> struct tail_impl; template <typename x, typename xs> struct tail_impl<cons<x, xs>> : xs { }; template <typename x, typename ...xs> struct tail_impl<list<x, xs...>> : list<xs...> { }; template <typename n, typename self> struct at_impl : instantiate<mpl11::Iterable>::with<List>::at_impl<n, self> { }; template <typename n, typename ...xs> struct at_impl<n, list<xs...>> : detail::at_index::best<n::type::value, xs...> { }; template <typename> struct is_empty_impl : false_ { }; }; template <> struct Iterable<List>::is_empty_impl<list<>> : true_ { }; template <> struct Functor<List> : instantiate<Functor>::with<List> { template <typename f, typename xs> struct fmap_impl; template <typename f, typename ...xs> struct fmap_impl<f, list<xs...>> { using type = list<typename f::type::template apply<xs>...>; }; template <typename f, typename x, typename xs> struct fmap_impl<f, cons<x, xs>> { using type = cons< typename f::type::template apply<x>, fmap<f, xs> >; }; }; template <typename f, typename x> struct iterate : cons<x, iterate<f, typename f::type::template apply<x>>> { }; template <typename x> struct repeat : cons<x, repeat<x>> { }; namespace list_detail { template <detail::std_size_t n, typename xs, bool = n == 0 || is_empty<xs>::value> struct take_impl : list<> { }; template <detail::std_size_t n, typename xs> struct take_impl<n, xs, false> : cons<head<xs>, take_impl<n-1, tail<xs>>> { }; template <typename n, typename xs> struct take_checks { static_assert(n::type::value >= 0, "Invalid usage of `take`: " "The number of elements to take must be non-negative."); }; template <typename xs, typename from, typename to> struct slice_checks { private: static constexpr auto start = from::type::value; static constexpr auto stop = to::type::value; static_assert(start >= 0, "Invalid usage of `slice`: The start index must be non-negative."); static_assert(start <= stop, "Invalid usage of `slice`: " "The start index must be less-than or equal to the stop index."); }; template <typename xs> struct init_checks { static_assert(!is_empty<xs>::value, "Invalid usage of `init` on an empty list."); }; } template <typename n, typename xs> struct take : list_detail::take_checks<n, xs>, list_detail::take_impl<n::type::value, xs> { }; template <typename xs, typename from, typename to> struct slice : list_detail::slice_checks<xs, from, to>, take_c<to::type::value - from::type::value, drop<from, xs>> { }; template <typename xs> struct init : list_detail::init_checks<xs>, if_c<is_empty<tail<xs>>::value, list<>, cons<head<xs>, init<tail<xs>>> > { }; namespace list_detail { template <typename pred> struct take_while_op { using type = take_while_op; template <typename x, typename xs> using apply = if_c< (bool)pred::type::template apply<x>::type::value, cons<x, xs>, list<> >; }; template <typename pred> struct filter_op { using type = filter_op; template <typename x, typename xs> using apply = if_c< (bool)pred::type::template apply<x>::type::value, cons<x, xs>, xs >; }; } template <typename f, typename state, typename xs> struct scanl : if_c<is_empty<xs>::value, list<state>, cons< state, scanl<f, apply<f, state, head<xs>>, tail<xs>> > > { }; template <typename f> struct zip_with<f> : list<> { }; template <typename f, typename xs> struct zip_with<f, xs> : fmap<f, xs> { }; template <typename f, typename ...lists> struct zip_with : if_<or_<is_empty<lists>...>, list<>, cons< typename f::type::template apply<head<lists>...>, zip_with<f, tail<lists>...> > > { }; template <typename ...xs> struct concat : foldr<lift<concat>, list<>, list<xs...>> { }; template <typename xs, typename ys> struct concat<xs, ys> : foldr<lift<cons>, ys, xs> { }; namespace list_detail { template < typename pred, typename xs, typename pivot = head<xs>, typename rest = tail<xs>, typename IsGreater = partial<pred, pivot>, typename IsSmallerEq = compose<lift<not_>, IsGreater>, typename SmallerEq = filter<IsSmallerEq, rest>, typename Greater = filter<IsGreater, rest> > using sort_by_impl = concat< sort_by<pred, SmallerEq>, cons<pivot, sort_by<pred, Greater>> >; } template <typename pred, typename xs> struct sort_by : if_c<or_<is_empty<xs>, is_empty<tail<xs>>>::value, xs, list_detail::sort_by_impl<pred, xs> > { }; template <typename f, typename state, typename ...xs> struct foldl<f, state, list<xs...>> : detail::left_folds::variadic< f::type::template apply, state, xs... > { }; template <typename f, typename state, typename ...xs> struct foldr<f, state, list<xs...>> : detail::right_folds::variadic< f::type::template apply, state, xs... > { }; template <typename ...xs, typename ys> struct length<foldr<lift<cons>, list<xs...>, ys>> : size_t<length<ys>::value + sizeof...(xs)> { }; template <typename index, typename x> struct at<index, repeat<x>> : x { }; }} namespace boost { namespace mpl11 { template <typename Datatype, typename = true_> struct Monad; template <typename monad> struct join; template <typename MonadType, typename x> struct unit; }} namespace boost { namespace mpl11 { template <typename monad> struct join : Monad<typename datatype<typename monad::type>::type>:: template join_impl<monad> { }; template <typename MonadType, typename x> struct unit : Monad<MonadType>::template unit_impl<x> { }; template <> struct instantiate<Monad> { template <typename Datatype> struct with : true_ { static_assert(Functor<Datatype>::value, "Monad requires Functor"); }; }; }} namespace boost { namespace mpl11 { struct Rational; template <typename T, T numerator, T denominator = (T)1> struct rational_c; }} namespace boost { namespace mpl11 { template <typename T, T numerator, T denominator> struct rational_c { using type = rational_c; using mpl_datatype = Rational; static constexpr T num = numerator; static constexpr T den = denominator; }; template <> struct cast<Integer, Rational> { using type = cast; template <typename i> using apply = rational_c< typename i::value_type, i::value >; }; template <> struct Monoid<Rational> : instantiate<Monoid>::with<Rational> { template <typename x, typename y> using plus_impl = rational_c< decltype(true ? x::num : y::num), (x::num * y::den) + (x::den * y::num), x::den * y::den >; template <typename ...> using zero_impl = rational_c<long long, 0>; }; template <> struct Group<Rational> : instantiate<Group>::with<Rational> { template <typename x, typename y> using minus_impl = rational_c< decltype(true ? x::num : y::num), (x::num * y::den) - (x::den * y::num), x::den * y::den >; template <typename x> using negate_impl = rational_c< decltype(-x::num), -x::num, x::den >; }; template <> struct Ring<Rational> : instantiate<Ring>::with<Rational> { template <typename x, typename y> using mult_impl = rational_c< decltype(true ? x::num : y::num), x::num * y::num, x::den * y::den >; template <typename ...> using one_impl = rational_c<long long, 1>; }; template <> struct Field<Rational> : instantiate<Field>::with<Rational> { template <typename x, typename y> using quot_impl = rational_c< decltype(true ? x::num : y::num), x::num * y::den, x::den * y::num >; template <typename x> using recip_impl = rational_c< decltype(x::num), x::den, x::num >; }; template <> struct Comparable<Rational> : instantiate<Comparable>::with<Rational> { template <typename x, typename y> using equal_impl = bool_< x::num * y::den == x::den * y::num >; template <typename x, typename y> using not_equal_impl = bool_< x::num * y::den != x::den * y::num >; }; template <> struct Orderable<Rational> : instantiate<Orderable>::with<Rational> { template <typename x, typename y> using less_impl = bool_<( x::num * y::den < x::den * y::num )>; template <typename x, typename y> using less_equal_impl = bool_<( x::num * y::den <= x::den * y::num )>; template <typename x, typename y> using greater_impl = bool_<( x::num * y::den > x::den * y::num )>; template <typename x, typename y> using greater_equal_impl = bool_<( x::num * y::den >= x::den * y::num )>; }; }}
#endif
