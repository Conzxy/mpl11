##############################################################################
# Utilities
##############################################################################
require "benchcc"
require "gnuplot"
require "rake"
require "ruby-progressbar"


class Plot < Gnuplot::Plot
  include Rake::DSL

  def initialize(name)
    super() { }
    @datasets = task name.to_s + "_datasets", [:compiler]

    task name, [:compiler] => [@datasets.name] do
      Gnuplot.open do |process|
        process << to_gplot
        process << store_datasets
      end
    end

    yield self if block_given?
  end

  def dataset(**env, &block)
    block ||= proc { }
    @datasets.enhance do |_, args|
      cc = Benchcc::Compiler[args.compiler]
      ctx = env.merge(compiler: cc)
      data << Gnuplot::DataSet.new { |ds| block.call(ds, ctx) }
    end
  end
end

class ManyInputPlot < Plot
  def dataset(input, y, **env)
    _input = Proc === input ? input : proc { input }
    super(**env) do |ds, ctx|
      yield ds, ctx if block_given?

      xs = _input.call(ctx).to_a

      progress = ProgressBar.create(format: "#{ds.title} %p%% | %B |", total: xs.size)
      ys = xs.map { |x|
        y.call(ctx.merge(input: x))
         .tap{ progress.increment }
      }
      ds.data = [xs, ys]
      puts ds.data
    end
  end
end

class TimingPlot < ManyInputPlot
  def initialize(name)
    super do |plot|
      plot.xlabel "Input size"
      plot.ylabel "Compilation time"
      plot.format 'y "%f s"'
      yield plot if block_given?
    end
  end

  attr_accessor :input_file

  def dataset(xs, file = nil, **env, &block)
    file ||= input_file
    compute = -> (ctx) { ctx[:compiler].rtime(file, ctx).real }
    super(xs, compute, **env, &block)
  end
end

class MemusgPlot < ManyInputPlot
  def initialize(name)
    super do |plot|
      plot.xlabel "Input size"
      plot.ylabel "Peak memory usage"
      plot.format 'y "%f kb"'
      yield plot if block_given?
    end
  end

  attr_accessor :input_file

  def dataset(xs, file = nil, **env)
    file ||= input_file
    compute = -> (ctx) { raise NotImplementedError }
    super(xs, compute, **env, &block)
  end
end


def procify(x)
  Proc === x ? x : proc { x }
end

def flexible_range(from, to, step = 1)
  from, to, step = procify(from), procify(to), procify(step)
  proc { |*args|
    (from.call(*args)..to.call(*args)).step(step.call(*args))
  }
end

template_depth = proc { |ctx| ctx[:compiler].template_depth }
constexpr_depth = proc { |ctx| ctx[:compiler].constexpr_depth }


##############################################################################
# Compiler registration with Benchcc
##############################################################################
def def_compiler(id, cmd, template_depth, constexpr_depth)
  Benchcc::GccFrontend.new id do |cc|
    cc.binary = `which #{cmd}`.strip
    raise "#{cmd} not found" unless $?.success?

    cc.template_depth = template_depth
    cc.constexpr_depth = constexpr_depth
    cc.wflags = %w{-Wall -Wextra -pedantic -fsyntax-only}
    cc.includes = %w{~/code/mpl11/include}
  end
end

#            id         command         template-depth  constexpr-depth
def_compiler(:apple51 , "clang"       , 256             , 512)
def_compiler(:clang34 , "clang++-3.4" , 256             , 512)
def_compiler(:clang35 , "clang++-3.5" , 256             , 512)
def_compiler(:gcc49   , "g++-4.9"     , 900             , 512)



##############################################################################
# Benchmark registration
##############################################################################
task :default => [:all]

desc "Run all the tasks."
task :all => [:comparison, :techniques]

desc "Benchmark MPL vs MPL11."
benchmark_suite :comparison do

  def auto
    proc { |ds, env|
      ds.with = "lines"
      fairness = env[:fair] ? "fair" : "unfair"
      ruliness = env[:rules] ? " with rules" : ""
      ds.title = "#{env[:config]} (#{fairness}#{ruliness})"
    }
  end

  def comparison(name)
    TimingPlot.new name do |plot|
      plot.title name
      plot.term "png"
      plot.output "comparison/#{name}.png"
      plot.input_file = "comparison/#{name}.erb.cpp"
      yield plot if block_given?
    end
  end

  %w{at fmap fmap_nested foldl}.each do |operation|
    comparison operation do |plot|
      plot.input_file = "comparison/sequence_operation.erb.cpp"

      dataset = proc { |*args, **kw|
        plot.dataset(*args, **kw, operation: operation, &auto)
      }

      dataset.call(1..250, config: "mpl11::list", fair: false, rules: true)
      dataset.call(1..250, config: "mpl11::list", fair: false, rules: false)
      dataset.call(1..50,  config: "mpl::vector", fair: false)
      dataset.call(1..50,  config: "mpl::list",   fair: false)

      dataset.call(1..50, config: "mpl11::list", fair: true, rules: true)
      dataset.call(1..50, config: "mpl11::list", fair: true, rules: false)
      dataset.call(1..50, config: "mpl::vector", fair: true)
      dataset.call(1..50, config: "mpl::list",   fair: true)
    end
  end

  task :include_all, [:compiler] do |bm, args|
    cc = Benchcc::Compiler[args.compiler]
    mpl = cc.rtime("comparison/include_all.erb.cpp", config: :mpl)
    mpl11 = cc.rtime("comparison/include_all.erb.cpp", config: :mpl11)
    puts <<-EOS
mpl:       #{mpl}\
mpl11:     #{mpl11}\
mpl/mpl11: #{mpl/mpl11}
EOS
  end

  comparison :plus do |plot|
    plot.dataset(2..250, config: :mpl11, fair: true, &auto)
    plot.dataset(2..250, config: :mpl11, fair: false, &auto)
    plot.dataset(2..5,   config: :mpl, fair: true, &auto)
    plot.dataset(2..5,   config: :mpl, fair: false, &auto)
  end
end

desc "Benchmark different implementation techniques."
benchmark_suite :techniques do

  def technique(name)
    TimingPlot.new name do |plot|
      plot.title name
      plot.term "png"
      plot.output "techniques/#{name}.png"
      plot.input_file = "techniques/#{name}.erb.cpp"
      yield plot if block_given?
    end
  end

  technique :alias_vs_struct do |plot|
    plot.dataset((0..10_000).step(20), config: :alias)
    plot.dataset((0..10_000).step(20), config: :struct)
  end

  technique :at_index do |plot|
    plot.dataset(0..500, config: :overload)
    plot.dataset(0..500, config: :multiple_inheritance)
  end

  technique :at_key do |plot|
    plot.dataset(0..500, config: :multiple_inheritance)
    plot.dataset(flexible_range(0, template_depth), config: :single_inheritance)
  end

  technique :foldl do |plot|
    plot.dataset(flexible_range(0, template_depth), config: :aliases)
    plot.dataset(flexible_range(0, template_depth), config: :standard_recursion)
  end

  technique :implement_metafunction do |plot|
    plot.dataset((0..10_000).step(10), config: :specialize)
    plot.dataset((0..10_000).step(10), config: :delegate)
  end

  technique :invoke_metafunction do |plot|
    plot.dataset((0..5_000).step(10), config: :flat_nested_type)
    plot.dataset(flexible_range(0, template_depth, 10), config: :recursive_forwarding)
    plot.dataset(flexible_range(0, template_depth, 10), config: :recursive_nested_type)
  end

  technique :max do |plot|
    plot.dataset(2..500, config: :union)
    plot.dataset(flexible_range(2, constexpr_depth), config: :standard_recursion)
    plot.dataset(flexible_range(2, constexpr_depth), config: :recursive_constexpr)
  end

  technique :mention_vs_instantiate do |plot|
    plot.dataset((0..5_000).step(10), config: :mention)
    plot.dataset((0..5_000).step(10), config: :instantiate)
  end

  technique :or do |plot|
    %i{overload noexcept recursive_constexpr specialization}.each { |cfg|
      plot.dataset(0..500, config: cfg)
    }

    plot.dataset(flexible_range(0, template_depth), config: :structs)
    plot.dataset(flexible_range(0, template_depth), config: :short_circuit_structs)
  end

  technique :sum do |plot|
    plot.dataset(flexible_range(2, constexpr_depth), config: :accumulating_constexpr)
    plot.dataset(flexible_range(2, constexpr_depth), config: :recursive_constexpr)
    plot.dataset(flexible_range(2, template_depth), config: :recursive_struct)
    plot.dataset(2..500, config: :sizeof_trick)
  end

  technique :trampoline do |plot|
    %i{standard_recursion aliases macro_quantifier constexpr_quantifier}.each { |cfg|
      plot.dataset((1..30_000).step(100), config: cfg)
    }
  end

  technique :while do |plot|
    plot.dataset(flexible_range(0, template_depth), config: :aliases)
    plot.dataset(flexible_range(0, template_depth), config: :standard_recursion)
  end
end