<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>mpl11: Iterable</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">mpl11
   </div>
   <div id="projectbrief">Template metaprogramming for humans</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">Iterable<div class="ingroups"><a class="el" href="group__typeclasses.html">Type classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>Data structures allowing external iteration.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1mpl11_1_1iterable__tag.html">boost::mpl11::iterable_tag</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tag representing the <code>Iterable</code> typeclass.  <a href="structboost_1_1mpl11_1_1iterable__tag.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1mpl11_1_1is__empty.html">boost::mpl11::is_empty&lt; Iter &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean <code>StaticConstant</code> representing whether the iterable is empty.  <a href="structboost_1_1mpl11_1_1is__empty.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1mpl11_1_1at__c.html">boost::mpl11::at_c&lt; Iter, Index &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code><a class="el" href="structboost_1_1mpl11_1_1at__c.html" title="Equivalent to at_c&lt;Iter, size_t&lt;Index&gt;&gt;. ">at_c</a>&lt;Iter, <a class="el" href="structboost_1_1mpl11_1_1size__t.html" title="Alias to integral_c&lt;std::size_t, N&gt;; provided for convenience. ">size_t</a>&lt;Index&gt;&gt;</code>.  <a href="structboost_1_1mpl11_1_1at__c.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1mpl11_1_1length.html">boost::mpl11::length&lt; Iter &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>StaticConstant</code> of unsigned type representing the number of elements in a finite iterable.  <a href="structboost_1_1mpl11_1_1length.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1mpl11_1_1unpack.html">boost::mpl11::unpack&lt; Iter, F &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invokes a metafunction class with the contents of a finite iterable.  <a href="structboost_1_1mpl11_1_1unpack.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1mpl11_1_1_iterable_3_01iterable__tag_01_4.html">boost::mpl11::Iterable&lt; iterable_tag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines the default operations for iterables.  <a href="structboost_1_1mpl11_1_1_iterable_3_01iterable__tag_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1mpl11_1_1_comparable_3_01iterable__tag_00_01iterable__tag_01_4.html">boost::mpl11::Comparable&lt; iterable_tag, iterable_tag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default instantiation of the <code>Comparable</code> typeclass for iterables.  <a href="structboost_1_1mpl11_1_1_comparable_3_01iterable__tag_00_01iterable__tag_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1mpl11_1_1_orderable_3_01iterable__tag_00_01iterable__tag_01_4.html">boost::mpl11::Orderable&lt; iterable_tag, iterable_tag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default instantiation of the <code>Orderable</code> typeclass for iterables.  <a href="structboost_1_1mpl11_1_1_orderable_3_01iterable__tag_00_01iterable__tag_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1mpl11_1_1_foldable_3_01iterable__tag_01_4.html">boost::mpl11::Foldable&lt; iterable_tag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default instantiation of the <code>Foldable</code> typeclass for iterables.  <a href="structboost_1_1mpl11_1_1_foldable_3_01iterable__tag_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1mpl11_1_1_functor_3_01iterable__tag_01_4.html">boost::mpl11::Functor&lt; iterable_tag &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default instantiation of the <code>Functor</code> typeclass for iterables.  <a href="structboost_1_1mpl11_1_1_functor_3_01iterable__tag_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1mpl11_1_1cons.html">boost::mpl11::cons&lt; Head, Tail &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterable with an element prepended to it.  <a href="structboost_1_1mpl11_1_1cons.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1mpl11_1_1drop__while.html">boost::mpl11::drop_while&lt; Predicate, Iter &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Drops elements from an iterable up to, but not including, the first element for which the <code>Predicate</code> returns <code>false</code>.  <a href="structboost_1_1mpl11_1_1drop__while.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1mpl11_1_1iterate.html">boost::mpl11::iterate&lt; F, X &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an infinite iterable containing repeated applications of a metafunction class to an initial argument.  <a href="structboost_1_1mpl11_1_1iterate.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1mpl11_1_1join.html">boost::mpl11::join&lt; Iters &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate several iterables.  <a href="structboost_1_1mpl11_1_1join.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1mpl11_1_1repeat.html">boost::mpl11::repeat&lt; T &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an infinite iterable containing copies of the given type.  <a href="structboost_1_1mpl11_1_1repeat.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1mpl11_1_1scanl.html">boost::mpl11::scanl&lt; F, State, Iter &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>scanl</code> is similar to <code>foldl</code>, but returns an iterable of successive reduced values from the left.  <a href="structboost_1_1mpl11_1_1scanl.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1mpl11_1_1slice.html">boost::mpl11::slice&lt; Iter, Start, Stop &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a subrange of an iterable.  <a href="structboost_1_1mpl11_1_1slice.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1mpl11_1_1snoc.html">boost::mpl11::snoc&lt; Init, Last &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterable with an element appended to its end.  <a href="structboost_1_1mpl11_1_1snoc.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1mpl11_1_1sort__by.html">boost::mpl11::sort_by&lt; Predicate, Iter &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterable sorted with the <code>Predicate</code>.  <a href="structboost_1_1mpl11_1_1sort__by.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1mpl11_1_1take__while.html">boost::mpl11::take_while&lt; Predicate, Iter &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the longest prefix of an iterable in which all elements satisfy the <code>Predicate</code>.  <a href="structboost_1_1mpl11_1_1take__while.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1mpl11_1_1zip.html">boost::mpl11::zip&lt; Iters &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterable that aggregates elements from several iterables.  <a href="structboost_1_1mpl11_1_1zip.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gad50ff76e5200fec380735897c94012b4"><td class="memTemplParams" colspan="2">template&lt;typename N , typename Iter &gt; </td></tr>
<tr class="memitem:gad50ff76e5200fec380735897c94012b4"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___iterable.html#gad50ff76e5200fec380735897c94012b4">boost::mpl11::drop</a> = rules::drop_impl&lt; N, Iter &gt;</td></tr>
<tr class="memdesc:gad50ff76e5200fec380735897c94012b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterable containing the suffix of another iterable after the first <code>N</code> elements.  <a href="#gad50ff76e5200fec380735897c94012b4">More...</a><br/></td></tr>
<tr class="separator:gad50ff76e5200fec380735897c94012b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9cdb3a8538c66e941efa7bc8459f885b"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga9cdb3a8538c66e941efa7bc8459f885b"></a>
template&lt;detail::std_size_t N, typename Iter &gt; </td></tr>
<tr class="memitem:ga9cdb3a8538c66e941efa7bc8459f885b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___iterable.html#ga9cdb3a8538c66e941efa7bc8459f885b">boost::mpl11::drop_c</a> = drop&lt; size_t&lt; N &gt;, Iter &gt;</td></tr>
<tr class="memdesc:ga9cdb3a8538c66e941efa7bc8459f885b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>drop&lt;<a class="el" href="structboost_1_1mpl11_1_1size__t.html" title="Alias to integral_c&lt;std::size_t, N&gt;; provided for convenience. ">size_t</a>&lt;N&gt;, Iter&gt;</code>; provided for convenience. <br/></td></tr>
<tr class="separator:ga9cdb3a8538c66e941efa7bc8459f885b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c0bf00e70b29b9b58d47dedcd2ce8d9"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga4c0bf00e70b29b9b58d47dedcd2ce8d9"></a>
template&lt;typename Predicate , typename Iter &gt; </td></tr>
<tr class="memitem:ga4c0bf00e70b29b9b58d47dedcd2ce8d9"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___iterable.html#ga4c0bf00e70b29b9b58d47dedcd2ce8d9">boost::mpl11::drop_until</a> = drop_while&lt; compose&lt; quote&lt; not_ &gt;, Predicate &gt;, Iter &gt;</td></tr>
<tr class="memdesc:ga4c0bf00e70b29b9b58d47dedcd2ce8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code><a class="el" href="structboost_1_1mpl11_1_1drop__while.html" title="Drops elements from an iterable up to, but not including, the first element for which the Predicate r...">drop_while</a></code> with a negated <code>Predicate</code>. <br/></td></tr>
<tr class="separator:ga4c0bf00e70b29b9b58d47dedcd2ce8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32db75ab9c2ae6dbe9b9d2c7376f65b3"><td class="memTemplParams" colspan="2">template&lt;typename Predicate , typename Iter &gt; </td></tr>
<tr class="memitem:ga32db75ab9c2ae6dbe9b9d2c7376f65b3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___iterable.html#ga32db75ab9c2ae6dbe9b9d2c7376f65b3">boost::mpl11::filter</a> = rules::filter_impl&lt; Predicate, Iter &gt;</td></tr>
<tr class="memdesc:ga32db75ab9c2ae6dbe9b9d2c7376f65b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterable containing only the elements satisfying the <code>Predicate</code>.  <a href="#ga32db75ab9c2ae6dbe9b9d2c7376f65b3">More...</a><br/></td></tr>
<tr class="separator:ga32db75ab9c2ae6dbe9b9d2c7376f65b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3dce9130c89c2ca4837afd655669b87e"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga3dce9130c89c2ca4837afd655669b87e"></a>
template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:ga3dce9130c89c2ca4837afd655669b87e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___iterable.html#ga3dce9130c89c2ca4837afd655669b87e">boost::mpl11::reverse</a> = rules::reverse_impl&lt; Iter &gt;</td></tr>
<tr class="memdesc:ga3dce9130c89c2ca4837afd655669b87e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the elements of an iterable in reverse order. <br/></td></tr>
<tr class="separator:ga3dce9130c89c2ca4837afd655669b87e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6de84eaf9c4646c00657b755a22e327b"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga6de84eaf9c4646c00657b755a22e327b"></a>
template&lt;typename Iter , detail::std_size_t Start, detail::std_size_t Stop&gt; </td></tr>
<tr class="memitem:ga6de84eaf9c4646c00657b755a22e327b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___iterable.html#ga6de84eaf9c4646c00657b755a22e327b">boost::mpl11::slice_c</a> = slice&lt; Iter, size_t&lt; Start &gt;, size_t&lt; Stop &gt;&gt;</td></tr>
<tr class="memdesc:ga6de84eaf9c4646c00657b755a22e327b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>slice&lt;Iter, <a class="el" href="structboost_1_1mpl11_1_1size__t.html" title="Alias to integral_c&lt;std::size_t, N&gt;; provided for convenience. ">size_t</a>&lt;Start&gt;, <a class="el" href="structboost_1_1mpl11_1_1size__t.html" title="Alias to integral_c&lt;std::size_t, N&gt;; provided for convenience. ">size_t</a>&lt;Stop&gt;&gt;</code>. <br/></td></tr>
<tr class="separator:ga6de84eaf9c4646c00657b755a22e327b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83120e8941eadc6e79ceb77a84287654"><td class="memTemplParams" colspan="2">template&lt;typename N , typename Iter &gt; </td></tr>
<tr class="memitem:ga83120e8941eadc6e79ceb77a84287654"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___iterable.html#ga83120e8941eadc6e79ceb77a84287654">boost::mpl11::take</a> = rules::take_impl&lt; N, Iter &gt;</td></tr>
<tr class="memdesc:ga83120e8941eadc6e79ceb77a84287654"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an iterable containing the first <code>N</code> elements of another iterable.  <a href="#ga83120e8941eadc6e79ceb77a84287654">More...</a><br/></td></tr>
<tr class="separator:ga83120e8941eadc6e79ceb77a84287654"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefbcbda863b53814a7ed34ef9799acba"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaefbcbda863b53814a7ed34ef9799acba"></a>
template&lt;detail::std_size_t N, typename Iter &gt; </td></tr>
<tr class="memitem:gaefbcbda863b53814a7ed34ef9799acba"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___iterable.html#gaefbcbda863b53814a7ed34ef9799acba">boost::mpl11::take_c</a> = take&lt; size_t&lt; N &gt;, Iter &gt;</td></tr>
<tr class="memdesc:gaefbcbda863b53814a7ed34ef9799acba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code>take&lt;<a class="el" href="structboost_1_1mpl11_1_1size__t.html" title="Alias to integral_c&lt;std::size_t, N&gt;; provided for convenience. ">size_t</a>&lt;N&gt;, Iter&gt;</code>. <br/></td></tr>
<tr class="separator:gaefbcbda863b53814a7ed34ef9799acba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga680e0545b32a6618e43a1a13aa0f11ed"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga680e0545b32a6618e43a1a13aa0f11ed"></a>
template&lt;typename Predicate , typename Iter &gt; </td></tr>
<tr class="memitem:ga680e0545b32a6618e43a1a13aa0f11ed"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___iterable.html#ga680e0545b32a6618e43a1a13aa0f11ed">boost::mpl11::take_until</a> = take_while&lt; compose&lt; quote&lt; not_ &gt;, Predicate &gt;, Iter &gt;</td></tr>
<tr class="memdesc:ga680e0545b32a6618e43a1a13aa0f11ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equivalent to <code><a class="el" href="structboost_1_1mpl11_1_1take__while.html" title="Returns the longest prefix of an iterable in which all elements satisfy the Predicate. ">take_while</a></code> with a negated <code>Predicate</code>. <br/></td></tr>
<tr class="separator:ga680e0545b32a6618e43a1a13aa0f11ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Data structures allowing external iteration. </p>
<h3>Methods</h3>
<p><code>head</code>, <code>tail</code>, <code><a class="el" href="structboost_1_1mpl11_1_1is__empty.html" title="Boolean StaticConstant representing whether the iterable is empty. ">is_empty</a></code>, <code>last</code>, <code>init</code>, <code><a class="el" href="structboost_1_1mpl11_1_1at__c.html" title="Equivalent to at_c&lt;Iter, size_t&lt;Index&gt;&gt;. ">at_c</a></code>, <code>at</code>, <code>length</code> and <code>unpack</code>.</p>
<p><code><a class="el" href="structboost_1_1mpl11_1_1at__c.html" title="Equivalent to at_c&lt;Iter, size_t&lt;Index&gt;&gt;. ">at_c</a></code> is only a wrapper over <code>at</code>. It is provided for convenience but it is not implemented inside the typeclass.</p>
<h3>Minimal complete definition</h3>
<p><code>head</code>, <code>tail</code> and <code><a class="el" href="structboost_1_1mpl11_1_1is__empty.html" title="Boolean StaticConstant representing whether the iterable is empty. ">is_empty</a></code>.</p>
<h3>Provides</h3>
<ul>
<li><code>Comparable</code> when the elements in the iterable are <code>Comparable</code>.</li>
<li><code>Orderable</code> when the elements in the iterable are <code>Orderable</code>.</li>
<li><code>Foldable</code></li>
<li><code>Functor</code></li>
</ul>
<dl class="section note"><dt>Note</dt><dd><code>Iterable</code>s are not required to be finite. If an <code>Iterable</code> is infinite, some methods such as <code>length</code> and <code>unpack</code> are not well-defined. The well-definedness of some other methods such as <code>init</code> and <code>last</code> depends on the particular iterable.</dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>Support lazy sequence traits.</dd></dl>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="gad50ff76e5200fec380735897c94012b4"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename N , typename Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group___iterable.html#gad50ff76e5200fec380735897c94012b4">boost::mpl11::drop</a> = typedef rules::drop_impl&lt;N, Iter&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterable containing the suffix of another iterable after the first <code>N</code> elements. </p>
<p><code>N</code> must be a non-negative <code>StaticConstant</code> representing the number of elements to be dropped from the underlying iterable. If <code>N</code> is greater than the length of the iterable, the returned iterable is empty.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>Try optimizing the recursion in the implementation. </dd></dl>

</div>
</div>
<a class="anchor" id="ga32db75ab9c2ae6dbe9b9d2c7376f65b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Predicate , typename Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group___iterable.html#ga32db75ab9c2ae6dbe9b9d2c7376f65b3">boost::mpl11::filter</a> = typedef rules::filter_impl&lt;Predicate, Iter&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterable containing only the elements satisfying the <code>Predicate</code>. </p>
<p>If the underlying iterable is infinite, the iterable returned by <code>filter</code> is finite if and only if the <code>Predicate</code> is <code>false</code> for an infinite suffix of the iterable. However, since this is hard to determine without actually performing the computation and should be rare anyways, the returned iterable is trait-wise infinite whenever the underlying iterable is infinite. </p>

</div>
</div>
<a class="anchor" id="ga83120e8941eadc6e79ceb77a84287654"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename N , typename Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group___iterable.html#ga83120e8941eadc6e79ceb77a84287654">boost::mpl11::take</a> = typedef rules::take_impl&lt;N, Iter&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an iterable containing the first <code>N</code> elements of another iterable. </p>
<p><code>N</code> must be a non-negative <code>StaticConstant</code> representing the number of elements to keep in the underlying iterable. If <code>N</code> is greater than the length of the iterable, all of its elements are kept. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Jan 19 2014 17:50:09 for mpl11 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
